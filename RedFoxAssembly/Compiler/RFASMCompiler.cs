using RedFoxAssembly.TokenParser;
using System.Text;
using System.Text.RegularExpressions;
using System.Security.Cryptography;
using RedFoxAssembly.Compiler.Tokens;

namespace RedFoxAssembly.Compiler
{
    /// <summary>
    /// Compiler for converting a list of RF ASM instructions into binary for interpretation. 
    /// Each instruction (for example, "LDA 0xaf") should be on a new line, and arguments are seperated by a space.
    /// </summary>
    class RFASMCompiler
    {
        public const int DATA_WIDTH = 2;

        private static Dictionary<string, byte[]> labels = new Dictionary<string, byte[]>();
        private static Dictionary<string, byte[]> constants = new Dictionary<string, byte[]>();

        static Task<int> Main(string[] args)
        {
            return Task.Run(() =>
            {
                RFASMCompiler compiler = new RFASMCompiler();
                return compiler.Start(args);
            });
        }

        private int Start(string[] args)
        {
            Console.WriteLine("");
            Console.WriteLine(" <==> RFASM Compiler, by GenElectrovise for Gamesmaster3000X");
            Console.WriteLine(" <==> https://github.com/gamesmaster3000x/RF_ASM");

            // <==> Preparing
            Console.WriteLine("");
            Console.WriteLine(" <==> Preparing");

            bool USE_AUTOWIRED_ARGUMENTS = false;
            if (USE_AUTOWIRED_ARGUMENTS)
            {
                Console.WriteLine("Using autowired program arguments (ignoring " + args.Length + " input arguments)");
                string testProgramsPath = "../../../Documentation/TestPrograms/"; // Escape bin, Debug, and net6.0
                args = new string[] { "-INPUT_PATH", testProgramsPath + "test_dw1.rfp", "-DATA_WIDTH", "1", "-RANDOM_ARG", "-OTHER_RANDOM_ARG", " ", "CONFUSION", "-" };
            }

            Console.WriteLine("Parsing arguments");
            RFASMCompilerMetadata meta = new RFASMCompilerMetadata(args);

            if (meta.InputPath == null || meta.InputPath.Equals(""))
            {
                meta.InputPath = GetInputFilePath();
            }
            else
            {
                Console.WriteLine("Found input path " + meta.InputPath + " via program arguments");
            }

            // <==> Parsing
            Console.WriteLine("");
            Console.WriteLine(" <==> Parsing");

            string[] rawLinesArr = File.ReadAllLines(meta.InputPath);
            List<string> rawLines = rawLinesArr.ToList();
            Console.WriteLine("Found " + rawLinesArr.Length + " lines");

            ITokenGenerator generator = new RFASMTokenGenerator(meta);
            TokenParser.TokenParser parser = new TokenParser.TokenParser(RFASMTokenGenerator.GOOD_TOKEN, RFASMTokenGenerator.IGNORE_TOKEN, RFASMTokenGenerator.BAD_TOKEN, meta, generator);
            List<IToken> tokens = parser.Parse(rawLines);
            string tokenHash = ComputeTokenListHash(tokens);
            Console.WriteLine("Hash of token raw values: " + tokenHash);

            // <==> Compiling
            Console.WriteLine("");
            Console.WriteLine(" <==> Compiling");

            Console.WriteLine("Checking syntax");
            CheckSyntax(tokens);
            Console.WriteLine("Doing pre-compilation pass");
            List<IToken> passedTokens = PreCompilationPass(tokens);
            Console.WriteLine("Bytifying");
            List<byte> compiledBytes = CompileTokens(passedTokens);

            Console.WriteLine("Generated bytes:");
            CompilerUtils.DisplayHexDump(compiledBytes.ToArray());

            // <==> Writing
            Console.WriteLine("");
            Console.WriteLine(" <==> Writing");
            WriteCompilation(meta.InputPath, compiledBytes.ToArray());

            Console.WriteLine("");
            Console.WriteLine(" <==> Done");
            Console.WriteLine(" <==> https://github.com/gamesmaster3000x/RF_ASM");
            Console.WriteLine(" <==> RFASM Compiler, by GenElectrovise for Gamesmaster3000X");
            Console.WriteLine("");

            return 0;
        }

        private List<IToken> PreCompilationPass(List<IToken> tokens)
        {
            List<IToken> result = new List<IToken>();

            for(int i = 0; i < tokens.Count; i++)
            {
                IToken token = tokens[i];

                /*
                 * .width 1
                 * LDR VALUE REG
                 * .val VALUE #f7
                 * .val REG &02
                 * 
                 * { DATA_WIDTH=1, VALUE=#f7, REG=&02 }
                 * LDR VALUE REG
                 */
                if (token is DirectiveToken)
                {
                    DirectiveToken directiveToken = (DirectiveToken)token;
                    int skip = directiveToken.ResolveDirective(this, tokens.GetRange(i + 1, 2)); // TODO DirectiveToken may cause out of bound errors
                    i += skip;
                    continue;
                }

                /*
                 * LDR #03 &01  (0, 1, 2)
                 * :LABEL       (3)
                 * LDR #a5 &02  (4, 5, 6)
                 * B _LABEL     (7, 8)
                 * 
                 * Declare label LABEL is at index 3
                 * 
                 * LDR #03 &01  (0, 1, 2)
                 * LDR #a5 &02  (3, 4, 5)
                 * B *03        (6, 7)
                 * 
                 * The result list will be 3 items long at the point of considering :LABEL, so the index to jump to is 3
                 */
                if (token is LabelDeclarationToken)
                {
                    LabelDeclarationToken labelDeclarationToken = (LabelDeclarationToken)token;
                    List<IToken> cut = labelDeclarationToken.DeclareLabel(this, result.Count);
                    continue;
                }

                result.Add(token);
            }

            return result;
        }

        private void CheckSyntax(List<IToken> tokens)
        {
            for(int i = 0; i < tokens.Count; i++)
            {
                IToken[] following = new IToken[3];
                IToken token = tokens[i];
                
                if (tokens.Count > i + 1)
                {
                    following[0] = tokens[i + 1];
                }
                if (tokens.Count > i + 2)
                {
                    following[1] = tokens[i + 2];
                }
                if (tokens.Count > i + 3)
                {
                    following[2] = tokens[i + 3];
                }

                if (!token.CheckFollowing(following))
                {
                    IToken[] preceeding = new IToken[2];
                    if (i - 2 > -1)
                    {
                        preceeding[0] = tokens[i - 2];
                    }
                    if (i - 1 > -1)
                    {
                        preceeding[1] = tokens[i - 1];
                    }
                    IToken[] line = preceeding.Concat(following).ToArray();
                    throw new TokenSyntaxException(line, i);
                }
            }
        }

        private List<byte> CompileTokens(List<IToken>? tokens)
        {
            List<byte> compiledBytes = new List<byte>();
            for (int i = 0; i < tokens.Count; i++)
            {
                IToken token = tokens[i];
                byte[] ba = token.GetBytes();
                if(ba == null)
                {
                    continue;
                }
                if(ba.Length > 0)
                {
                    compiledBytes.AddRange(ba);
                }
            }

            return compiledBytes;
        }

        private void WriteCompilation(string inputPath, byte[] bytes)
        {
            string outputPath = GetOutputFileName(inputPath);
            FileInfo outputFileInfo = new FileInfo(outputPath);
            Console.WriteLine("Storing compilation to " + outputFileInfo.FullName);
            BinaryWriter writer = new BinaryWriter(File.Open(outputPath, FileMode.OpenOrCreate));
            writer.Write(bytes);
            writer.Flush();
            writer.Close();
        }

        private string GetInputFilePath()
        {
            Console.Write("Enter the name of the file to be compiled (including the file extension): ");
            string inputPath = Console.ReadLine();
            FileInfo inputFileInfo = new FileInfo(inputPath);
            if (!inputFileInfo.Exists)
            {
                throw new FileNotFoundException("Cannot file the file " + inputFileInfo.FullName);
            }

            return inputPath;
        }

        /// <summary>
        /// Generates the name of the output file based on the input file. For example Program.rfx will become Program.rfbin.
        /// </summary>
        /// <param name="inputFileName"></param>
        /// <returns></returns>
        public string GetOutputFileName(string inputFileName)
        {
            // The input file extension and output file extension
            string RF_BIN_FileEnding = "rfb";

            // Fancy regular expression stuff to replace the .input with the .output
            // () are a class
            // Searches for the final . , then takes everything after it and replaces with the new file ending
            return Regex.Replace(inputFileName, "([^.]+$)", RF_BIN_FileEnding);
        }

        /// <summary>
        /// Generate a hash based on the values of the raw values of the input tokens. For identical assemblies, this should be the same.
        /// </summary>
        /// <param name="tokens"></param>
        /// <returns></returns>
        private string ComputeTokenListHash(List<IToken>? tokens)
        {
            // Two decently sized prime numbers
            long seed = 3873849883; 
            long modifier = 4064799121;

            // Collect the token values
            StringBuilder builder = new StringBuilder();
            foreach (IToken token in tokens)
            {
                builder.Append(token.GetRawValue);
            }
            string value = builder.ToString();

            // Hash and convert to a string of hex values
            HashAlgorithm algorithm = SHA256.Create();
            byte[] hashBytes = algorithm.ComputeHash(Encoding.Default.GetBytes(value));
            string hexStr = BitConverter.ToString(hashBytes);
            return hexStr;
        }
    }
}
