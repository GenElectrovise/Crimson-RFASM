using Crimson.CSharp.Core;
using Crimson.CSharp.Exceptions;
using Crimson.CSharp.Generalising;
using Crimson.CSharp.Generalising.Structures;
using Crimson.CSharp.Parsing;
using Crimson.CSharp.Parsing.Statements;
using Crimson.CSharp.Parsing.Tokens;
using NLog;
using System.Text.RegularExpressions;

namespace Crimson.CSharp.Generalising
{
    internal class Generaliser
    {
        private static readonly Logger LOGGER = LogManager.GetCurrentClassLogger();

        public GeneralAssemblyProgram Generalise (Compilation compilation)
        {
            GeneralAssemblyProgram program = new GeneralAssemblyProgram();

            GeneralisationContext context = new GeneralisationContext();

            Dictionary<string, FunctionCStatement> functions = new Dictionary<string, FunctionCStatement>();
            Dictionary<string, StructureCStatement> structures = new Dictionary<string, StructureCStatement>();
            Dictionary<string, GlobalVariableCStatement> variables = new Dictionary<string, GlobalVariableCStatement>();

            /*
             * Create 3 universal lists which contain all of the statements.
             * These have already been dynamically mapped (they know which singletons each call refers to).
             * During collection, these values are reassigned names (which are globally updated) to avoid name clashes.
             */
            foreach (KeyValuePair<string, Scope> pair in compilation.Library.Units)
            {
                foreach (var f in pair.Value.Functions)
                {
                    FixNameAndAdd(functions, f.Value);
                }
                foreach (var s in pair.Value.Structures)
                {
                    FixNameAndAdd(structures, s.Value);
                }
                foreach (var g in pair.Value.GlobalVariables)
                {
                    FixNameAndAdd(variables, g.Value);
                }
            }

            // Add versioning and credits
            program.AddStructure(new CommentAssemblyStructure("This CrimsonBasic program was automatically generated by the Crimson compiler."));
            program.AddStructure(new CommentAssemblyStructure("Copyright (c) 2022-2023 GenElectrovise https://github.com/GenElectrovise and GamesMaster3000X https://github.com/gamesmaster3000x"));
            program.AddStructure(new CommentAssemblyStructure("Crimson version " + Core.Crimson.VERSION));
            program.AddStructure(new CommentAssemblyStructure("Crimson, CrimsonBasic and RedFoxAssembly are parts of GamesMaster3000X's RedFoxVirtualMachine."));
            program.AddStructure(new CommentAssemblyStructure("The main repository for this project can be found at: https://github.com/gamesmaster3000x/RF_ASM"));
            program.AddStructure(new CommentAssemblyStructure("Crimson, CrimsonBasic and RedFoxAssembly were implemented by me, GenElectrovise."));
            program.AddStructure(new CommentAssemblyStructure("My development fork of the project can be found at: https://github.com/GenElectrovise/RF_ASM"));
            program.AddStructure(new CommentAssemblyStructure(""));

            // Add global variables
            program.AddStructure(new CommentAssemblyStructure(""));
            program.AddStructure(new CommentAssemblyStructure("============================== Global Variables =============================="));
            foreach (var pair in variables)
            {
                IGeneralAssemblyStructure bs = pair.Value.Generalise(context);
                program.AddStructure(bs);
                LOGGER.Debug($"Added GlobalVariable {pair.Value.Assignment.Name}");
            }

            // Add structures
            program.AddStructure(new CommentAssemblyStructure(""));
            program.AddStructure(new CommentAssemblyStructure("(Structures shouldn't be a part of CB)"));
            program.AddStructure(new CommentAssemblyStructure("============================== Structures =============================="));
            foreach (var pair in structures)
            {
                IGeneralAssemblyStructure bs = pair.Value.Generalise(context);
                program.AddStructure(bs);
                LOGGER.Debug($"Added Structure {pair.Value.Name}");
            }

            // Add main (entry) function
            program.AddStructure(new CommentAssemblyStructure(""));
            program.AddStructure(new CommentAssemblyStructure("============================== Entry Function =============================="));
            FunctionCStatement entry = compilation.GetEntryFunction();
            LOGGER.Info($"Found entry Function {entry.Name}");
            IGeneralAssemblyStructure entryBs = entry.Generalise(context);
            program.AddStructure(entryBs);
            LOGGER.Debug($"Added entry Function {entry.Name}");

            // Add remaining functions
            program.AddStructure(new CommentAssemblyStructure(""));
            program.AddStructure(new CommentAssemblyStructure("============================== Functions =============================="));
            foreach (var pair in functions)
            {
                if (pair.Value == entry) continue;
                IGeneralAssemblyStructure bs = pair.Value.Generalise(context);
                program.AddStructure(bs);
                LOGGER.Debug($"Added Function {pair.Value.Name}");
            }

            return program;
        }

        private void FixNameAndAdd<GS> (Dictionary<string, GS> map, GS gs) where GS : INamed
        {
            int i = 0;
            string prefix = GetFlattenedPrefix(gs.GetType());
            while (map.ContainsKey(gs.GetName() + "_" + i))
            {
                i++;
            }
            gs.SetName(new FullNameCToken($"{prefix}_{gs.GetName()}_{i}"));
            map.Add(gs.GetName().ToString(), gs);
        }

        private string GetFlattenedPrefix (Type type)
        {
            if (type == typeof(FunctionCStatement))
            {
                return "func";
            }
            if (type == typeof(StructureCStatement))
            {
                return "stru";
            }
            if (type == typeof(GlobalVariableCStatement))
            {
                return "gvar";
            }
            if (type == typeof(ScopeVariableCStatement))
            {
                return "ivar";
            }
            return "";
        }
    }
}
