// This CrimsonBasic program was automatically generated by the Crimson compiler.
// Crimson version v0.0
// CrimsonBasic version v0.0
// Copyright (c) 2022 GenElectrovise https://github.com/GenElectrovise and GamesMaster3000X https://github.com/gamesmaster3000x
// In case of problems with this compiler, register an issue or contact the authors at https://github.com/gamesmaster3000x/RF_ASM


// ============================== Global Variables ==============================
stack allocate gvar_counter_0 4
set gvar_counter_0 GLO_VAR_ASSIGN_VAL;

// (Structures shouldn't be a part of CB)
// ============================== Structures ==============================
// GlobalC:stru_Person_0

// ============================== Entry Function ==============================
:func_main_0
stack push_frame 
    
    set rval_0 true == true;
    jeq rval_0 0 NEXT_ELIF
        set counter VAR_ASSIGN_C_VAL;
        jump END_branch_0
    
    jump utils.multiply
    set rval_1 FUNC_RETURN;
    // arg0=rval_1
    jump utils.times
    heap allocate rval_2 6969
    register set REG_RETURN rval_2
    set rval_2 FUNC_RETURN;
    set rval_3 rval_2 == true;
    jeq rval_3 0 NEXT_ELIF
        jump utils.times
        set rval_4 FUNC_RETURN;
        // arg0=rval_4
        jump heap.alloc
        heap allocate rval_5 6969
        register set REG_RETURN rval_5
        set rval_5 FUNC_RETURN;
        stack allocate a 4
        set a INT_VAR_ASSIGN_VAL;
        jump END_branch_1
    
    :ELSE
        return;
    :END_branch_1
    
    :END_branch_0
    
    // arg0=4
    // arg1=7
    // arg2=5
    jump call
    heap allocate rval_6 6969
    register set REG_RETURN rval_6
    set rval_6 FUNC_RETURN;
    // arg0=4
    jump heap.alloc
    heap allocate rval_7 6969
    register set REG_RETURN rval_7
    set rval_7 FUNC_RETURN;
    stack allocate i 666
    set i INT_VAR_ASSIGN_VAL;
    set i* VAR_ASSIGN_C_VAL;
    // arg0=i
    jump stdout.write
    heap allocate rval_8 6969
    register set REG_RETURN rval_8
    set rval_8 FUNC_RETURN;
    return;
stack pop_frame 
return;


// ============================== Functions ==============================
:func_multiply_0
stack push_frame 
    // arg0=6
    jump utils_stdout.write
    heap allocate rval_9 6969
    register set REG_RETURN rval_9
    set rval_9 FUNC_RETURN;
    return;
stack pop_frame 
return;

:func_times_0
stack push_frame 
    return;
stack pop_frame 
return;

:func_write_0
stack push_frame 
stack pop_frame 
return;

:func_alloc_0
stack push_frame 
    stack allocate i 4
    set i INT_VAR_ASSIGN_VAL;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
    return;
stack pop_frame 
return;

:func_get_region_ptr_0
stack push_frame 
    stack allocate RRMS 4
    set RRMS INT_VAR_ASSIGN_VAL;
    stack allocate exponential_offset 4
    set exponential_offset INT_VAR_ASSIGN_VAL;
    
    set rval_10 r < 0;
    jeq rval_10 0 NEXT_ELIF
        jump END_branch_2
    
    set rval_11 r == 0;
    jeq rval_11 0 NEXT_ELIF
        set exponential_offset VAR_ASSIGN_C_VAL;
        jump END_branch_3
    
    set rval_12 r == 1;
    jeq rval_12 0 NEXT_ELIF
        set exponential_offset VAR_ASSIGN_C_VAL;
        jump END_branch_4
    
    :ELSE
        
        //  >> TODO IMPLEMENT WHILE (start) <<
        //  >> TODO IMPLEMENT WHILE (end) <<
        
    :END_branch_4
    
    :END_branch_3
    
    :END_branch_2
    
    stack allocate HO_EXP 4
    set HO_EXP INT_VAR_ASSIGN_VAL;
    stack allocate HO_EXP_RRMS 4
    set HO_EXP_RRMS INT_VAR_ASSIGN_VAL;
    return;
stack pop_frame 
return;

:func_freeptr_0
stack push_frame 
    stack allocate r 4
    set r INT_VAR_ASSIGN_VAL;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
    // arg0=r
    jump freeregion
    heap allocate rval_13 6969
    register set REG_RETURN rval_13
    set rval_13 FUNC_RETURN;
stack pop_frame 
return;

:func_freeregion_0
stack push_frame 
    set regions_region VAR_ASSIGN_C_VAL;
stack pop_frame 
return;

:func_pwr_0
stack push_frame 
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
stack pop_frame 
return;

:func_call_0
stack push_frame 
    // arg0=69
    jump heap.alloc
    heap allocate rval_14 6969
    register set REG_RETURN rval_14
    set rval_14 FUNC_RETURN;
    stack allocate test 4
    set test INT_VAR_ASSIGN_VAL;
    return;
stack pop_frame 
return;

