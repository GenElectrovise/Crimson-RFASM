// This CrimsonBasic program was automatically generated by the Crimson compiler.
// Crimson version v0.0
// CrimsonBasic version v0.0
// Copyright (c) 2022 GenElectrovise https://github.com/GenElectrovise and GamesMaster3000X https://github.com/gamesmaster3000x
// In case of problems with this compiler, register an issue or contact the authors at https://github.com/gamesmaster3000x/RF_ASM


// ============================== Global Variables ==============================
inc_sp 666;
var_set gvar_regions_i_0, -1, 0;
inc_sp 666;
var_set gvar_regions_length_0, -1, 0;
inc_sp 666;
var_set gvar_regions_region_0, -1, 0;
inc_sp 666;
var_set gvar_counter_0, -1, 0;

// (Structures shouldn't be a part of CB)
// ============================== Structures ==============================
// GlobalC:stru_Person_0

// ============================== Entry Function ==============================
:func_main_0:
push_sf;
    example basic call
    ~A "example assemby call"
    // Function Call
    inc_sp 666;
    var_set a, -1, ;
    // Function Call
    inc_sp 666;
    var_set b, -1, ;
    
    jeq c_r_h 0 NEXT_ELIF
        // 5
        jump END_branch_0
    
    jeq c_r_h 0 NEXT_ELIF
        // Function Call
        inc_sp 666;
        var_set c, -1, ;
        // Function Call
        inc_sp 666;
        var_set d, -1, ;
        jump END_branch_1
    
    :ELSE:
        return;
    :END_branch_1:
    
    :END_branch_0:
    
    // arg0=4
    // arg1=7
    // arg2=5
    jump call
    reg_set REG_RETURN rval_0
    var_set rval_0, -1, FUNC_RETURN;
    // Function Call
    inc_sp 666;
    var_set i, -1, ;
    // 4
    // arg0=i
    jump stdout.write
    reg_set REG_RETURN rval_1
    var_set rval_1, -1, FUNC_RETURN;
    // Function Call
    inc_sp 666;
    var_set ret, -1, ;
    // Function Call
    var_set ret, -1, VAR_ASSIGN_C_VAL;
    return;
push_sf;
return;


// ============================== Functions ==============================
:func_multiply_0:
push_sf;
    // arg0=6
    jump utils_stdout.write
    reg_set REG_RETURN rval_2
    var_set rval_2, -1, FUNC_RETURN;
    return;
push_sf;
return;

:func_times_0:
push_sf;
    // Function Call
    inc_sp 666;
    var_set ret, -1, ;
    return;
push_sf;
return;

:func_write_0:
push_sf;
push_sf;
return;

:func_alloc_0:
push_sf;
    inc_sp 666;
    var_set i, -1, 0;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
    return;
push_sf;
return;

:func_get_region_ptr_0:
push_sf;
    // Operation
    inc_sp 666;
    var_set RRMS, -1, ;
    inc_sp 666;
    var_set exponential_offset, -1, 4;
    
    jeq c_r_h 0 NEXT_ELIF
        jump END_branch_2
    
    jeq c_r_h 0 NEXT_ELIF
        // 1
        jump END_branch_3
    
    jeq c_r_h 0 NEXT_ELIF
        // 2
        jump END_branch_4
    
    :ELSE:
        
        //  >> TODO IMPLEMENT WHILE (start) <<
        //  >> TODO IMPLEMENT WHILE (end) <<
        
    :END_branch_4:
    
    :END_branch_3:
    
    :END_branch_2:
    
    // Operation
    inc_sp 666;
    var_set HO_EXP, -1, ;
    // Operation
    inc_sp 666;
    var_set HO_EXP_RRMS, -1, ;
    return;
push_sf;
return;

:func_freeptr_0:
push_sf;
    inc_sp 666;
    var_set r, -1, 0;
    // Function Call
    inc_sp 666;
    var_set region_ptr, -1, ;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
    // arg0=r
    jump freeregion
    reg_set REG_RETURN rval_3
    var_set rval_3, -1, FUNC_RETURN;
push_sf;
return;

:func_freeregion_0:
push_sf;
    // 0
push_sf;
return;

:func_pwr_0:
push_sf;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
push_sf;
return;

:func_call_0:
push_sf;
    // Function Call
    inc_sp 666;
    var_set test, -1, ;
    return;
push_sf;
return;

