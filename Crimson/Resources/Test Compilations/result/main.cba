// This CrimsonBasic program was automatically generated by the Crimson compiler.
// Crimson version v0.0
// CrimsonBasic version v0.0
// Copyright (c) 2022 GenElectrovise https://github.com/GenElectrovise and GamesMaster3000X https://github.com/gamesmaster3000x
// In case of problems with this compiler, register an issue or contact the authors at https://github.com/gamesmaster3000x/RF_ASM


// ============================== Global Variables ==============================
stack allocate gvar_regions_i_0 666;
set gvar_regions_i_0, -1, 0;
stack allocate gvar_regions_length_0 666;
set gvar_regions_length_0, -1, 0;
stack allocate gvar_regions_region_0 666;
set gvar_regions_region_0, -1, 0;
stack allocate gvar_counter_0 666;
set gvar_counter_0, -1, 0;

// (Structures shouldn't be a part of CB)
// ============================== Structures ==============================
// GlobalC:stru_Person_0

// ============================== Entry Function ==============================
:func_main_0:
stack push_frame ;
    example basic call
    ~A "example assemby call"
    // Function Call
    stack allocate a 666;
    set a, -1, ;
    // Function Call
    stack allocate b 666;
    set b, -1, ;
    
    jeq c_r_h 0 NEXT_ELIF
        // 5
        jump END_branch_0
    
    jeq c_r_h 0 NEXT_ELIF
        // Function Call
        stack allocate c 666;
        set c, -1, ;
        // Function Call
        stack allocate d 666;
        set d, -1, ;
        jump END_branch_1
    
    :ELSE:
        return;
    :END_branch_1:
    
    :END_branch_0:
    
    // arg0=4
    // arg1=7
    // arg2=5
    jump call
    register set REG_RETURN rval_0
    set rval_0, -1, FUNC_RETURN;
    // Function Call
    stack allocate i 666;
    set i, -1, ;
    // 4
    // arg0=i
    jump stdout.write
    register set REG_RETURN rval_1
    set rval_1, -1, FUNC_RETURN;
    // Function Call
    stack allocate ret 666;
    set ret, -1, ;
    // Function Call
    set ret, -1, VAR_ASSIGN_C_VAL;
    return;
stack pop_frame ;
return;


// ============================== Functions ==============================
:func_multiply_0:
stack push_frame ;
    // arg0=6
    jump utils_stdout.write
    register set REG_RETURN rval_2
    set rval_2, -1, FUNC_RETURN;
    return;
stack pop_frame ;
return;

:func_times_0:
stack push_frame ;
    // Function Call
    stack allocate ret 666;
    set ret, -1, ;
    return;
stack pop_frame ;
return;

:func_write_0:
stack push_frame ;
stack pop_frame ;
return;

:func_alloc_0:
stack push_frame ;
    stack allocate i 666;
    set i, -1, 0;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
    return;
stack pop_frame ;
return;

:func_get_region_ptr_0:
stack push_frame ;
    // Operation
    stack allocate RRMS 666;
    set RRMS, -1, ;
    stack allocate exponential_offset 666;
    set exponential_offset, -1, 4;
    
    jeq c_r_h 0 NEXT_ELIF
        jump END_branch_2
    
    jeq c_r_h 0 NEXT_ELIF
        // 1
        jump END_branch_3
    
    jeq c_r_h 0 NEXT_ELIF
        // 2
        jump END_branch_4
    
    :ELSE:
        
        //  >> TODO IMPLEMENT WHILE (start) <<
        //  >> TODO IMPLEMENT WHILE (end) <<
        
    :END_branch_4:
    
    :END_branch_3:
    
    :END_branch_2:
    
    // Operation
    stack allocate HO_EXP 666;
    set HO_EXP, -1, ;
    // Operation
    stack allocate HO_EXP_RRMS 666;
    set HO_EXP_RRMS, -1, ;
    return;
stack pop_frame ;
return;

:func_freeptr_0:
stack push_frame ;
    stack allocate r 666;
    set r, -1, 0;
    // Function Call
    stack allocate region_ptr 666;
    set region_ptr, -1, ;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
    // arg0=r
    jump freeregion
    register set REG_RETURN rval_3
    set rval_3, -1, FUNC_RETURN;
stack pop_frame ;
return;

:func_freeregion_0:
stack push_frame ;
    // 0
stack pop_frame ;
return;

:func_pwr_0:
stack push_frame ;
    
    //  >> TODO IMPLEMENT WHILE (start) <<
    //  >> TODO IMPLEMENT WHILE (end) <<
    
stack pop_frame ;
return;

:func_call_0:
stack push_frame ;
    // Function Call
    stack allocate test 666;
    set test, -1, ;
    return;
stack pop_frame ;
return;

