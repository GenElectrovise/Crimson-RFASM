// This CrimsonBasic program was automatically generated by the Crimson compiler.
// Crimson version v0.0
// CrimsonBasic version v0.0
// Copyright (c) 2022 GenElectrovise https://github.com/GenElectrovise and GamesMaster3000X https://github.com/gamesmaster3000x
// In case of problems with this compiler, register an issue or contact the authors at https://github.com/gamesmaster3000x/RF_ASM


// ============================== Global Variables ==============================
var gvar_counter_0;
stack allocate gvar_counter_0 666
gvar_counter_0 = GLO_VAR_ASSIGN_VAL;

// (Structures shouldn't be a part of CB)
// ============================== Structures ==============================
// GlobalC:stru_Person_0

// ============================== Entry Function ==============================
:func_main_0
stack push_frame 
    
    var rval_0;
    rval_0 = true == true;
    jeq rval_0 0 NEXT_ELIF
        stack allocate counter 6
        jump END_branch_0
    
    jump utils.multiply
    // ^^ Why is this not linked!? (utils.otherthing should be linked)
    var rval_1;
    rval_1 = FUNC_RETURN;
    // ^^ Perhaps need to dereference and copy/change ownership to not be overwritten?
    // arg0=rval_1
    jump utils.times
    var rval_2;
    rval_2 = FUNC_RETURN;
    // ^^ Perhaps need to dereference and copy/change ownership to not be overwritten?
    var rval_3;
    rval_3 = rval_2 == true;
    jeq rval_3 0 NEXT_ELIF
        var a;
        stack allocate a 666
        a = INT_VAR_ASSIGN_VAL;
        jump END_branch_1
    
    :ELSE
        return;
    :END_branch_1
    
    :END_branch_0
    
    // arg0=4
    // arg1=7
    // arg2=5
    jump call
    var rval_4;
    rval_4 = FUNC_RETURN;
    // ^^ Perhaps need to dereference and copy/change ownership to not be overwritten?
    var i;
    stack allocate i 666
    i = INT_VAR_ASSIGN_VAL;
    stack allocate i 4
    i = VAR_ASSIGN_C_VAL;
    // arg0=i
    jump stdout.write
    var rval_5;
    rval_5 = FUNC_RETURN;
    // ^^ Perhaps need to dereference and copy/change ownership to not be overwritten?
    return;
stack pop_frame 
return;


// ============================== Functions ==============================
:func_multiply_0
stack push_frame 
    // arg0=6
    jump utils_stdout.write
    var rval_6;
    rval_6 = FUNC_RETURN;
    // ^^ Perhaps need to dereference and copy/change ownership to not be overwritten?
    return;
stack pop_frame 
return;

:func_times_0
stack push_frame 
    return;
stack pop_frame 
return;

:func_write_0
stack push_frame 
stack pop_frame 
return;

:func_call_0
stack push_frame 
    stack allocate test 69
    return;
stack pop_frame 
return;

